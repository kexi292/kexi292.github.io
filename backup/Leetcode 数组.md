数组  --用连续的内存空间，存储一组具有相同类型的数据。

数组支持随机访问，根据下表随机访问的时间复杂度为O(1)。

为什么数组能根据下表支持随机访问？

> 计算机给每个内存单元分配一个地址，通过地址来访问内存中的数据，由于数组Array能根据下标计算地址（base_address + i * data_type_size）,就能直接访问对应的数据内容。

为什么插入和删除低效？

> 如果是在数组的末尾插入元素，不需要移动数据-O(1)。如果在开头插入元素，需要移动所有数据-O(n),插入每个位置的概率是一样的，平均时间复杂度为O(n)。
>
> 如果Array的数据是有序的，那么上述正确。但是如果无序，数组只是被当作存储数据的集合。那么如果要把某个数据插入第k个位置，可以直接把第k位的数据搬移到数组元素最后，将新元素放入到第k个位置。
>
> 删除操作也是类似，如果在数组末尾删除元素，-O(1)。如果i在数组开头删除元素，-O(n)，平均时间复杂度为-O(n)。
>
> 如果不一定非得最求数组中数据的连续性，可以把多次删除操作集中在一起执行，删除效率会提高。

ArrayList对比Array可以将很多操作封装起来，并支持动态扩容。

业务开发，直接使用容器，如果是非常底层的开发，追求性能，那么数组会由于容器


二分查找 确定查找区间

> 初始化`right`的时候是`nums.length`。nums.length是越界的，因此查找区间是`[left,rignt)`。当初始化`right`的时候是`nums.length - 1`。查找区间就是`[left,rignt]`。

两种二分算法的区别：
1. `[left,right]` 
循环结束判断使用` left <= right ` ,因为 `[2,2]` `有意义，查找空间不为空。`[left + 1, left] `查找空间才是空的。
`if (nums[middle] > target )`的时候，`right`需要更新为`middle - 1` ，查找空间更新为`[left,middle - 1]`。
3. `[left,right)`
循环结束判断使用` left < right` ，因为`[2,2)` 没有意义，查找空间已经是空的。
`if (nums[middle] > target ) `的时候，`right` 需要更新为 `middle` ,查找空间更新为`[left,middle)` ，因为middle是不在搜索区间里的。

扩展：
1）查找左侧边界：查找的数组中有重复数字，查找最左边的数字。
做法：使用左闭右闭的搜索空间,在查找到值的时候，压缩右侧的搜索空间。
`if (nums[middle] == target )` 的时候，`right = middle - 1` 。
返回的时候，返回的是left。
2）查找右侧边界：查找的数组中有重复数字，查找最右侧的数字。
做法：压缩左侧的搜索空间。
当使用左闭右闭的搜索空间的时候，在查找到值的时候。`if ((nums[middle] == target) ` ,`left = middle + 1` .
返回的时候，返回的是right。


参考链接1：[labuladong](https://labuladong.online/algo/essential-technique/binary-search-framework/)
参考链接2：[代码随想录](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF)